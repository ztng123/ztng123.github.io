---
layout: post
title: 🗓️ 구글 캘린더 API (1) 이벤트 만들기
tags: [google]
---

Google Calendar API는 명시적 HTTP 호출을 통해 또는 Google 클라이언트 라이브러리를 사용하여 액세스할 수 있는 RESTful API로 이를 사용해 이벤트 만들기

---

## 🔗 API 사용 준비

&nbsp;

#### OAuth 2.0 클라이언트 ID 생성


&nbsp;

1. [사용자 인증 정보](https://console.cloud.google.com/apis/credentials?hl=ko&_ga=2.108419079.467097148.1690425194-107950802.1690422893) 에 들어가기

&nbsp;

&nbsp;

2. OAuth 클라이언트 ID 생성

&nbsp;

<img width="437" alt="스크린샷 2023-07-27 오후 1 16 20" src="https://github.com/spring-projects/spring-security-samples/assets/53010592/bc208424-9861-4325-9294-dd266d07609e">

&nbsp;

&nbsp;

3. 입력

&nbsp;

<img width="536" alt="스크린샷 2023-08-07 오후 4 11 13" src="https://github.com/googleworkspace/java-samples/assets/53010592/4150aaef-1ed8-48e7-b204-9b131ac490a2">

- 리다이렉트 URI 설정

  ```
  http://localhost:8888/Callback
  ```

&nbsp;

&nbsp;

4. API 라이브러리

&nbsp;

   <img width="1319" alt="스크린샷 2023-08-07 오후 4 14 03" src="https://github.com/googleworkspace/java-samples/assets/53010592/2bbcf5b2-b9ed-4ed4-8545-4fcdebb5e968">

&nbsp;

Google Calendar 검색해서 사용하기

&nbsp;

&nbsp;


5. OAuth 동의 화면

&nbsp;

   <img width="1073" alt="스크린샷 2023-08-07 오후 4 17 00" src="https://github.com/googleworkspace/java-samples/assets/53010592/59e4f70e-2e0b-48f9-bc48-9729cc8b6d00">


&nbsp;

앱에 필요한 승인 범위 추가하기

&nbsp;

&nbsp;


## 📝 인증과 서비스 생성

&nbsp;

&nbsp;

#### OAuth 클라이언트 다운로드


&nbsp;

<img width="1046" alt="스크린샷 2023-08-07 오후 4 27 48" src="https://github.com/googleworkspace/java-samples/assets/53010592/665f2956-a4bb-41e3-a309-9b467907a63c">


&nbsp;

json 파일 다운로드 받아 credentials.json으로 파일이름 변경 후 /src/main/resources 폴더로 옮기기

&nbsp;

&nbsp;


#### build.gradle


&nbsp;

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.1.2'
    id 'io.spring.dependency-management' version '1.1.2'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
apply plugin: 'application'

mainClassName = 'CalendarQuickstart'
sourceCompatibility = 17
targetCompatibility = 17
version = '1.0'

java {
    sourceCompatibility = '17'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    implementation 'com.google.api-client:google-api-client:2.0.0'
    implementation 'com.google.oauth-client:google-oauth-client-jetty:1.34.1'
    implementation 'com.google.apis:google-api-services-calendar:v3-rev20220715-2.0.0'
}

tasks.named('test') {
    useJUnitPlatform()
}
```

&nbsp;

&nbsp;


#### CalendarQuickstart.java

&nbsp;

```java
@SpringBootApplication
public class CalendarQuickstart {

  private static final String APPLICATION_NAME = "Google Calendar API Java Quickstart";

  private static final JsonFactory JSON_FACTORY = GsonFactory.getDefaultInstance();

  private static final String TOKENS_DIRECTORY_PATH = "tokens"; //토큰 저장 경로

  private static final List<String> SCOPES =
      Collections.singletonList(CalendarScopes.CALENDAR_READONLY);
  private static final String CREDENTIALS_FILE_PATH = "/credentials.json";

  private static Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT)
      throws IOException {//인증에 필요한 객체 생성,반환

    InputStream in = CalendarQuickstart.class.getResourceAsStream(CREDENTIALS_FILE_PATH);
    if (in == null) {
      throw new FileNotFoundException("Resource not found: " + CREDENTIALS_FILE_PATH);
    }
    GoogleClientSecrets clientSecrets =
        GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));


    GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder( // 인증 흐름 만들기
        HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)
        .setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))
        .setAccessType("offline")
        .build();
    LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8888).build();
    Credential credential = new AuthorizationCodeInstalledApp(flow, receiver).authorize("user"); //사용자 인증,토큰 저장
    return credential;
  }

  public static void main(String... args) throws IOException, GeneralSecurityException {
    final NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
    Calendar service =
        new Calendar.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT))
            .setApplicationName(APPLICATION_NAME)
            .build();

    DateTime now = new DateTime(System.currentTimeMillis());
    Events events = service.events().list("primary")
        .setMaxResults(10)
        .setTimeMin(now)
        .setOrderBy("startTime")
        .setSingleEvents(true)
        .execute();
    List<Event> items = events.getItems(); // 가져온 이벤트 저장
    if (items.isEmpty()) {
      System.out.println("No upcoming events found.");
    } else {
      System.out.println("Upcoming events");
      for (Event event : items) {
        DateTime start = event.getStart().getDateTime();
        if (start == null) {
          start = event.getStart().getDate();
        }
        System.out.printf("%s (%s)\n", event.getSummary(), start); //이벤트 요약과 시작시간 출력

      }
    }
    SpringApplication.run(CalendarQuickstart.class, args);
  }
}
```

&nbsp;

&nbsp;


📌 scopes

&nbsp;

```java
private static final List<String> SCOPES =
      Collections.singletonList(CalendarScopes.CALENDAR_READONLY);
```

&nbsp;


요청하는 액세스 범위로 여기서는 캘린더에 대한 읽기 전용 액세스를 요청

&nbsp;

&nbsp;


📌 이벤트 가져오기

&nbsp;


```java
Events events = service.events().list("primary")
        .setMaxResults(10)
        .setTimeMin(now)
        .setOrderBy("startTime")
        .setSingleEvents(true)
        .execute();
```

&nbsp;

> `setMaxResults(n)` : 최대 n개의 이벤트 가져오기

&nbsp;


> `setTimeMin(datetime)` : datetime 이후의 이벤트만 가져오기

&nbsp;


> `setOrderBy("startTime")` : 이벤트를 시작 시간 순으로 정렬

&nbsp;


> `setSingleEvents(true)` : 반복되는 이벤트를 개별 이벤트로 표시

&nbsp;


> `.excute()` : 위의 설정에 따라 이벤트 가져오기

&nbsp;

&nbsp;

## 🪄 이벤트 생성

&nbsp;


캘린더 일정을 만들고 사용자의 캘린더에 추가하는 방법

&nbsp;

&nbsp;

#### 일정 추가

&nbsp;


📌 scopes

&nbsp;


```java
private static final List<String> SCOPES =
      Collections.singletonList(CalendarScopes.CALENDAR);
```

&nbsp;


OAuth 범위를 사용자의 캘린더에 대한 수정 액세스 권한을 부여하게 변경

&nbsp;

&nbsp;

⚠️ 403 PERMISSION_DENIED

&nbsp;


```
"code": 403,
  "details": [
    {
      "@type": "type.googleapis.com/google.rpc.ErrorInfo",
      "reason": "ACCESS_TOKEN_SCOPE_INSUFFICIENT"
    }
  ],
  "errors": [
    {
      "domain": "global",
      "message": "Insufficient Permission",
      "reason": "insufficientPermissions"
    }
  ],
  "message": "Request had insufficient authentication scopes.",
  "status": "PERMISSION_DENIED"
```

&nbsp;


권한이 제대로 변경되지 않았는데 이는 이미 존재하는 액세스 토큰에 의한 문제

&nbsp;

&nbsp;


📌 토큰 폴더 삭제

&nbsp;


위에 지정한 토큰 저장 경로 "tokens" 폴더 삭제하고 다시 실행하면 변경된 권한을 포함해 새로운 액세스 토큰 발급

&nbsp;

&nbsp;


📌 결과

&nbsp;


<img width="488" alt="스크린샷 2023-08-07 오후 12 02 09" src="https://github.com/googleworkspace/java-samples/assets/53010592/882102d8-aa25-4b6a-9759-62fe39407337">

&nbsp;

&nbsp;


📌 main()

&nbsp;



```java

public static void main(String... args) throws IOException, GeneralSecurityException {
    // . . .

    Event event = new Event()
        .setSummary("Google I/O 2023")
        .setLocation("800 Howard St., San Francisco, CA 94103")
        .setDescription("A chance to hear more about Google's developer products.");

    DateTime startDateTime = new DateTime("2023-08-07T09:00:00-07:00"); //시작시간
    EventDateTime start = new EventDateTime()
        .setDateTime(startDateTime)
        .setTimeZone("America/Los_Angeles");
    event.setStart(start);

    DateTime endDateTime = new DateTime("2023-08-07T17:00:00-07:00"); //종료시간
    EventDateTime end = new EventDateTime()
        .setDateTime(endDateTime)
        .setTimeZone("America/Los_Angeles");
    event.setEnd(end);

    String[] recurrence = new String[] {"RRULE:FREQ=DAILY;COUNT=2"}; //이벤트 반복
    event.setRecurrence(Arrays.asList(recurrence));

    EventAttendee[] attendees = new EventAttendee[] { // 참석자 추가
        new EventAttendee().setEmail("lpage@example.com"),
        new EventAttendee().setEmail("sbrin@example.com"),
    };
    event.setAttendees(Arrays.asList(attendees));

    EventReminder[] reminderOverrides = new EventReminder[] { // 알림 설정
        new EventReminder().setMethod("email").setMinutes(24 * 60), //24시간 전
        new EventReminder().setMethod("popup").setMinutes(10), //10분 전
    };
    Event.Reminders reminders = new Event.Reminders()
        .setUseDefault(false)
        .setOverrides(Arrays.asList(reminderOverrides));
    event.setReminders(reminders);

    String calendarId = "primary"; //이벤트를 사용자의 기본 캘린더에 추가
    event = service.events().insert(calendarId, event).execute();
    System.out.printf("Event created: %s\n", event.getHtmlLink());
}
```

&nbsp;


> `DateTime("YYYY-MM-DDTHH:MM:SS-시간대")`: 날짜+T(날짜와 시간 사이 구분하는 문자)+시간+시간대

&nbsp;


> `String[] recurrence = new String[] {"RRULE:FREQ=DAILY;COUNT=2"}` : 이벤트의 반복 설정하는 것으로 일일(DAILY) 총 2번(COUNT) 반복

&nbsp;


> `calendarId` : 캘린더를 식별하는데 사용되는 고유한 식별자

&nbsp;


> "primary"는 사용자의 기본 캘린더이고 각 캘린더는 고유한 calendarId를 갖고 있음

&nbsp;

&nbsp;

📌 calendarId 찾기

&nbsp;


```java
CalendarList calendarList = service.calendarList().list().execute();
for (CalendarListEntry calendarListEntry : calendarList.getItems()) {
    System.out.println("Calendar ID: " + calendarListEntry.getId());
}
```

&nbsp;

&nbsp;

📌 결과

&nbsp;


<img width="1858" alt="스크린샷 2023-08-07 오후 2 28 39" src="https://github.com/googleworkspace/java-samples/assets/53010592/b8fc6ea9-6c0d-42ff-97a7-1125fc58e0de">

&nbsp;

&nbsp;

#### Drive 첨부파일 추가

&nbsp;


📌 dependency 추가

&nbsp;


```gradle
implementation 'com.google.apis:google-api-services-drive:v3-rev20220815-2.0.0'
```

&nbsp;

&nbsp;


📌 연결 추가

&nbsp;


```java
public static void addAttachment(Calendar calendarService, Drive driveService, String calendarId,
                                    String eventId, String fileUrl)throws IOException {
    String fileId = extractFileIdFromUrl(fileUrl);
    File file = driveService.files().get(fileId).execute();
    Event event = calendarService.events().get(calendarId, eventId).execute();

    List<EventAttachment> attachments = event.getAttachments();
    if (attachments == null) {
    attachments = new ArrayList<EventAttachment>();
    }
    attachments.add(new EventAttachment()
    .setFileUrl("https://drive.google.com/file/d/" + fileId + "/view?usp=drive_link")
    .setMimeType(file.getMimeType())
    .setTitle(file.getName()));

    Event changes = new Event()
    .setAttachments(attachments);
    calendarService.events().patch(calendarId, eventId, changes)
    .setSupportsAttachments(true)
    .execute();
                                    }
public static void main(String... args) throws IOException, GeneralSecurityException {
    // . . .

    String fileUrl = "추가하고 싶은 드라이브 파일 URL"; 
    addAttachment(calendarService, driveService, calendarId, event.getId(), fileUrl);
}
```

구글드라이브 파일 url("https://drive.google.com/file/d/" + fileId + "/view?usp=drive_link")에서 fileId가 필요해 extractFileIdFromUrl(fileUrl)로 분리

&nbsp;

&nbsp;


📌fileId 추출

&nbsp;


```java
private static String extractFileIdFromUrl(String url) {
    String fileId = null;
    try {
        URL fileUrl = new URL(url);
        String path = fileUrl.getPath();
        Pattern pattern = Pattern.compile("file/d/(.*?)/");
        Matcher matcher = pattern.matcher(path);
        if (matcher.find()) {
            fileId = matcher.group(1);
        }
    } catch (MalformedURLException e) {
    e.printStackTrace();
    }
    return fileId;
}
```

&nbsp;

&nbsp;

📌 결과

&nbsp;


<img width="441" alt="스크린샷 2023-08-07 오후 3 25 08" src="https://github.com/googleworkspace/java-samples/assets/53010592/aa75a2ba-6b37-44a8-9216-307799c96bcf">

&nbsp;

&nbsp;

#### 화상회의 추가

&nbsp;


📌 main()

```java
public static void main(String... args) throws IOException, GeneralSecurityException {
    // . . .
    ConferenceSolutionKey conferenceSKey = new ConferenceSolutionKey();
    conferenceSKey.setType("hangoutsMeet"); //GoogleMeet 
    CreateConferenceRequest createConferenceReq = new CreateConferenceRequest(); //회의 생성
    createConferenceReq.setRequestId(UUID.randomUUID().toString()); 
    createConferenceReq.setConferenceSolutionKey(conferenceSKey);
    ConferenceData conferenceData = new ConferenceData();
    conferenceData.setCreateRequest(createConferenceReq);
    event.setConferenceData(conferenceData);

    //event = calendarService.events().insert(calendarId, event).execute();
    event = calendarService.events().insert(calendarId, event).setConferenceDataVersion(1).execute(); //회의 생성하고 이벤트에 추가
}
```

&nbsp;

>`.setConferenceDataVersion(1)` : Google Calendar API에 이벤트가 회의 데이터를 포함하고 있음을 알림
이로 인해 API는 회의를 생성하고, 회의 정보를 이벤트에 추가하며, 이벤트 참가자에게 회의에 대한 정보를 제공

&nbsp;

&nbsp;

📌 결과

&nbsp;


<img width="432" alt="스크린샷 2023-08-07 오후 3 34 30" src="https://github.com/googleworkspace/java-samples/assets/53010592/97c33076-1367-425d-9418-7f328093537e">

&nbsp;

&nbsp;


---
출처:[GoogleWorkspace](https://developers.google.com/calendar/api/guides/overview?hl=ko)